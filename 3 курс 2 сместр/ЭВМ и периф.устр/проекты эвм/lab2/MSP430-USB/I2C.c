/******************************************************************************/              
// I2C function
/******************************************************************************/              

/******************************************************************************/              
#include "function_prototype.h"
#include "system_define.h"
#include "I2C.h"
/******************************************************************************/              

//============================================================================
// Инициализация модуля UART0 для работы в режиме I2C
void Init_I2C()
{
  P3SEL |= 0x0A;           // Выбор альтернативной функции для линий порта P3
                           // в режиме I2C SDA->P3.1, SCL->P3.3
  U0CTL |= I2C + SYNC;     // Выбрать режим I2C для USART0
  U0CTL &= ~I2CEN;         // Выключить модуль I2C
// Конфигурация модуля I2C
  I2CTCTL=I2CSSEL_2;      // SMCLK
  I2CSCLH = 0x26;         // High period of SCL
  I2CSCLL = 0x26;         // Low period of SCL

  U0CTL |= I2CEN;         // Включить модуль I2C

  // формирование строба сброса I2C-регистров PCA9538 - RST_RG1->P3.1 и RST_RG2->P3.2
  P3DIR |= 0x05;            // переключаем эти ножки порта на вывод,
  P3SEL &= ~0x05;           //   выбираем функцию ввода-вывода для них
  P3OUT &= ~0x05;           //   и формируем строб сброса на 1 мс
  wait_1ms(1);
  P3OUT |= 0x05;
}
//============================================================================

//============================================================================
// отправка данных по протоколу I2C
void Send_I2C(unsigned char* buffer,unsigned int num, unsigned char address)
{
   while (I2CBUSY & I2CDCTL);            // проверка готовности модуля I2C
   BufTptr=buffer;
   I2CSA = address;                      // установка адреса приемнмка
   I2CNDAT =num;                         // количество передаваемых байт
   I2CIE = TXRDYIE+ALIE;                 // разрешение прерываний по окончанию передачи байта и по потере арбитража
   U0CTL |= MST;                         // режим Master
   I2CTCTL |= I2CSTT + I2CSTP + I2CTRX;  // инициализировать передачу

   while ((I2CTCTL & I2CSTP) == 0x02);   // ожидание условия СТОП
}
//============================================================================

//============================================================================
// прием данных по протоколу I2C
void Receive_I2C(unsigned char* buffer,unsigned int num, unsigned char address)
{
   while (I2CBUSY & I2CDCTL);            // проверка готовности модуля I2C
   BufRptr=buffer;
   I2CSA=address;
   I2CTCTL&=~I2CTRX;                     // режим приема
   I2CNDAT=num;
   I2CIE=RXRDYIE;                        // резрешение прерывания по окончанию приема байта
   U0CTL |= MST;
   I2CTCTL |= I2CSTT + I2CSTP;           // инициализировать прием

   while ((I2CTCTL & I2CSTP) == 0x02);   // ожидание условия СТОП
}
//============================================================================

//============================================================================
// отправка байта устройству на шине I2C
void I2C_SendByte(char data, char i2c_addr)
{
  Tx_Data[0] = data;                  // отправляемый байт
  Send_I2C(&Tx_Data[0], 1, i2c_addr); // вывод по I2C на устройство
}
//============================================================================


//============================================================================
// запись байта в регистр устройства на шине I2C
void I2C_WriteByte(char reg, char data, char i2c_addr)
{
  Tx_Data[0] = reg;                    // выбираем регистр
  Tx_Data[1] = data;                   // записываемые данные
  Send_I2C(&Tx_Data[0], 2, i2c_addr);  // вывод по I2C на устройство
}
//============================================================================


//============================================================================
// чтение байта из регистра устройства на шине I2C
byte I2C_ReadByte(char reg, char i2c_addr)
{
  Tx_Data[0] = reg;                       // выбираем регистр
  Send_I2C(&Tx_Data[0], 1, i2c_addr);
  Receive_I2C(&Rx_Data[0], 1, i2c_addr);  // получаем значение из регистра
  return Rx_Data[0];
}
//============================================================================


//============================================================================
// чтение слова (2 байта) из регистра устройства на шине I2C
int I2C_ReadWord(char reg, char i2c_addr)
{
  Tx_Data[0] = reg;                       // выбираем регистр
  Send_I2C(&Tx_Data[0], 1, i2c_addr);
  Receive_I2C(&Rx_Data[0], 2, i2c_addr);  // получаем 2 байта значение из регистра
  return Rx_Data[0] + (Rx_Data[1] * 256);
}
//============================================================================



//============================================================================
//Обработка прерывания от модуля USART0, работающего в режиме I2C

// вектор прерываний для модуля I2C
#pragma vector=USART0TX_VECTOR
__interrupt void I2C_ISR()
{
	switch(I2CIV)
	 {
	   case  0: break;                          // нет прерывания
	   case  2: break;                          // потеря арбитража
	   case  4: break;                          // нет подтверждения
	   case  6: break;                          // прерывание собственного адреса
	   case  8: break;                          // регистр доступен для чтения
	   case 10:                                 // окончание приема байта
	    *BufRptr++=I2CDRB;
	        break;
	   case 12:                                 // окончание передачи байта
	    I2CDRB=*BufTptr++;
	        break;
	   case 14: break;                          // общий вызов
	   case 16: break;                          // обнаружено условие СТАРТ
	 default : break;
	 }
}//============================================================================


//---------------------------------------------------------------------------
