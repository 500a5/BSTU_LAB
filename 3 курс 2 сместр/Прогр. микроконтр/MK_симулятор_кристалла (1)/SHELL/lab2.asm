org 0000h       		;Вектор рестарта процессора
                jmp begin
org 8100h
begin:          setb p1.0 	;Бит гашения преобразования
                clr psw.4	;Выбираем банк регистров
                clr psw.3
;                mov 2bh,#00011000b ;первый слева индикатор - 8
;                mov 2ch,#00100001b ;второй индикатор - 1
;                mov 2dh,#01000000b ;третий индикатор - 0
;                mov 2eh,#10000101b ;четвертый индикатор - 5 
                mov dptr,#03h ;Адрес РУ во внешней памяти
                mov a,#82h ;Содержимое РУ - 10000010b
                movx @dptr,a 
;                mov dpl,#02h ;Адрес порта С во внешней памяти
                
;B01:            mov r1,#0ah
;B06:            mov r2,#0ffh
;B05:            mov r0,#2eh

;B0A:            mov a,@r0
;                movx @dptr,a
;                mov r4,#0ffh
;B09:            djnz r4,B09 ;задержка для свечения индикатора
;                dec r0 ;выводим в порт С поочередно числа по адресам 2eh,2dh,2ch,2bh
;                cjne r0,#2ah, B0A
;B11:            djnz r4,B11
;                djnz r2,B05
;                djnz r1,B06
;заканчиваем выводить 8105 - "BIOS"
                mov dpl,#00h ;Адрес порта А во внешней памяти
                mov a,#10h
                movx @dptr,a ;Коммутатор передает напрядение с ножки 10h на АЦП
                clr p1.0 ;сбрасываем бит гашения преобразования
                jb p1.1,$ ;переход, если АЦП ещё не готов

L08:            mov dpl,#01h ;в DPTR адрес порта В во внешней памяти
                movx a,@dptr ;читаем в асс оцифрованное значение
                setb p1.0    ;устанавливаем бит гашения преобразования
                mov dpl,#02h ;в DPTR адрес порта С во внешней памяти
                add a,#80h   
                clr p1.0     ;сбрасываем бит гашения преобразования, АЦП начинает оцифровывать сигнал
                mov 00h,c    ;по нулевому адресу записываем бит переноса
                jnb acc.7,L00 ;если старший бит асс == 0, то переходим
                cpl a   ;инверсия +
                inc a   ;+ инкремент
L00:            mov b,#19h ;#25
                div ab    ;в асс-целое количество Вольт, в b-остаток
                setb acc.5 ;выводим на первый индикатор
                mov 10h,a ;сохр. подготовл. байт по адресу 10h
                mov a,b  ;работаем с остатком

                rl a  ;сдвиг влево //умножаем на 2
                rl a
                mov b,#0ah ;#10
                div ab     ;в асс количество десятых
                setb acc.6 ;выводим на третий индикатор
                mov 11h,a  ;сохраняем в памяти
                setb b.7   ;выводим на четвертый индикатор
                mov 12h,b  ;сохраняем в памяти

L01:            mov r1,#07h
L06:            mov r2,#0Fh
L05:            mov r0,#12h ; адрес байта для четвертого индикатора

L0A:            mov a,@r0 
                movx @dptr,a 
                mov r4,#00h
L09:            djnz r4,L09 ;задержка
                dec r0      ;переходим к байту для следующего индикатора
                cjne r0,#0fh, L0A ;последним выводим байт по адресу 10h
L11:            djnz r4,L11 ;задержка
                djnz r2,L05 
                djnz r1,L06 ;вложенные циклы
                jb 00h,L02 ;если число положительное, то переходим
                           ;иначе 
;                clr a      ;обнуляем асс
;                movx @dptr,a  ;гасим все индикаторы
                mov a,#00010000b
                movx @dptr,a
                mov r1,#07h
L04:            mov r2,#00h
L03:            djnz r2,L03
                djnz r1,L04 ;задержка
L02:            jb p1.1, L01 ;переходим,т.е. выводим то же самое число, если АЦП не готово
                jmp L08      ;если готово, то все заново
end
